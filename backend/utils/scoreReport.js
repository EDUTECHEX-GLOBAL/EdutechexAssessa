// backend/utils/scoreReport.js
const PDFDocument = require("pdfkit");
const { PassThrough } = require("stream");
const path = require("path");
const fs = require("fs");

// Logo path
const logoPath = path.join(__dirname, "assessalogo.png");
const logoExists = fs.existsSync(logoPath);

// Helper to convert PDFDocument stream to Buffer
const streamToBuffer = (stream) =>
  new Promise((resolve, reject) => {
    const chunks = [];
    stream.on("data", (chunk) => chunks.push(chunk));
    stream.on("end", () => resolve(Buffer.concat(chunks)));
    stream.on("error", reject);
  });

// Helper date formatting (robust)
const formatDate = (maybeDate) => {
  const d = maybeDate ? new Date(maybeDate) : new Date();
  if (isNaN(d.getTime())) return "—";
  return d.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'short', 
    day: 'numeric' 
  });
};

// Header with logo and title
const addHeader = (doc, title, color) => {
  const pageCenter = doc.page.width / 2;
  const startY = doc.page.margins.top;

  // Draw logo centered at the top with proper spacing
  if (logoExists) {
    try {
      const logoWidth = 92;
      const x = pageCenter - logoWidth / 2;
      doc.image(logoPath, x, startY, { width: logoWidth });
      doc.y = startY + logoWidth + 10; // Move cursor below the logo with proper spacing
    } catch (err) {
      // Fallback to text if image fails
      doc.font("Helvetica-Bold").fontSize(18).fillColor(color).text("Assessa", { align: "center" });
      doc.moveDown(0.5);
    }
  } else {
    doc.font("Helvetica-Bold").fontSize(18).fillColor(color).text("Assessa", { align: "center" });
    doc.moveDown(0.5);
  }

  // Add title
  doc.fillColor(color).fontSize(20).font("Helvetica-Bold").text(title, { align: "center" });
  doc.moveDown(0.8);
  
  // Add divider line
  const y = doc.y;
  doc.moveTo(doc.page.margins.left, y)
     .lineTo(doc.page.width - doc.page.margins.right, y)
     .strokeColor("#e0e0e0")
     .lineWidth(1)
     .stroke();
  doc.moveDown(1.5);
};

// Footer
const addFooter = (doc) => {
  const footerY = doc.page.height - 50;
  doc.y = footerY;
  doc.fontSize(9).fillColor("gray").font("Helvetica-Oblique")
    .text("This report was generated by Assessa for practice purposes.", { align: "center" });
  doc.text(`Generated on: ${formatDate(new Date())}`, { align: "center" });
};

// Draw an info card with title and value
const drawInfoCard = (doc, x, y, width, height, title, value, color = "#004D4D") => {
  // Draw card with subtle border
  doc.rect(x, y, width, height)
     .fillAndStroke("#fafafa", "#e0e0e0")
     .stroke();
  
  const padding = 10;
  const contentWidth = width - (padding * 2);
  
  // Add title
  doc.font("Helvetica-Bold").fontSize(9).fillColor("#666");
  const titleText = title.toUpperCase();
  doc.text(titleText, x + padding, y + 8, { 
    width: contentWidth,
    align: 'left'
  });
  
  // Add value - Use appropriate font size
  doc.font("Helvetica").fontSize(10).fillColor(color);
  const valueText = String(value || "—");
  doc.text(valueText, x + padding, y + 22, { 
    width: contentWidth,
    align: 'left'
  });
  
  return y + height;
};

// Draw a score card with visual indicators
const drawScoreCard = (doc, x, y, width, height, score, total, percentage, color = "#004D4D") => {
  // Draw main card
  doc.roundedRect(x, y, width, height, 5)
     .fillAndStroke("#f8f9fa", color)
     .stroke();
  
  // Add title
  doc.font("Helvetica-Bold").fontSize(12).fillColor(color)
     .text("SCORE SUMMARY", x + 15, y + 15, { width: width - 30, align: "center" });
  
  // Add score
  const scoreText = `${score}/${total}`;
  doc.font("Helvetica-Bold").fontSize(18).fillColor("#000")
     .text(scoreText, x + 15, y + 35, { width: width - 30, align: "center" });
  
  // Add percentage with visual indicator
  const percentageText = `${percentage}%`;
  const isGoodScore = percentage >= 70;
  const isAverageScore = percentage >= 50 && percentage < 70;
  
  doc.font("Helvetica").fontSize(12).fillColor(isGoodScore ? "green" : isAverageScore ? "orange" : "red")
     .text(percentageText, x + 15, y + 58, { width: width - 30, align: "center" });
  
  // Add performance indicator
  const performanceText = isGoodScore ? "Good" : isAverageScore ? "Average" : "Needs Improvement";
  doc.font("Helvetica").fontSize(9).fillColor(isGoodScore ? "green" : isAverageScore ? "orange" : "red")
     .text(performanceText, x + 15, y + 75, { width: width - 30, align: "center" });
  
  return y + height;
};

// Draw a table with rows (array of arrays). Columns widths passed.
const drawTable = (doc, startY, x, columnWidths, headers, rows, headerBg = "#004D4D") => {
  const padding = 8;
  let y = startY;
  const lineGap = 4;

  // Header box height estimated by text height
  doc.font("Helvetica-Bold").fontSize(10);
  const headerHeight = Math.max(16, doc.heightOfString(headers.join(" "), { width: columnWidths[0] })) + padding * 2;

  // Draw header bg for entire width
  const tableWidth = columnWidths.reduce((a, b) => a + b, 0);
  doc.rect(x, y, tableWidth, headerHeight).fillColor(headerBg).fill();

  // Write header texts
  let cx = x;
  doc.fillColor("#ffffff");
  headers.forEach((h, i) => {
    doc.font("Helvetica-Bold").fontSize(10).text(h, cx + padding, y + padding, { 
      width: columnWidths[i] - padding * 2,
      align: i > 0 ? "center" : "left" // Center align all columns except first
    });
    cx += columnWidths[i];
  });

  y += headerHeight + lineGap;
  doc.fillColor("black");

  // Rows
  rows.forEach((row, rowIndex) => {
    // Compute row height as max height among columns for the row
    const heights = row.map((cell, i) => {
      return doc.heightOfString(String(cell || ""), { 
        width: columnWidths[i] - padding * 2, 
        align: i > 0 ? "center" : "left" // Center align all columns except first
      });
    });
    const rowHeight = Math.max(...heights, 14) + padding * 2;

    // Page break if needed
    if (y + rowHeight > doc.page.height - doc.page.margins.bottom - 50) {
      doc.addPage();
      y = doc.page.margins.top;
    }

    // Draw row background alternate
    if (rowIndex % 2 === 0) {
      doc.rect(x, y, tableWidth, rowHeight).fillColor("#f8f9fa").fill();
    }

    // Draw cell texts
    cx = x;
    row.forEach((cell, i) => {
      doc.fillColor("black").font("Helvetica").fontSize(10)
        .text(String(cell ?? ""), cx + padding, y + padding, { 
          width: columnWidths[i] - padding * 2,
          align: i > 0 ? "center" : "left" // Center align all columns except first
        });
      cx += columnWidths[i];
    });

    // Draw row separator
    doc.moveTo(x, y + rowHeight)
       .lineTo(x + tableWidth, y + rowHeight)
       .strokeColor("#e0e0e0")
       .lineWidth(0.5)
       .stroke();

    y += rowHeight;
  });

  // Return final y for following content
  return y;
};

/**
 * Standard Assessment Report (includes detailed responses table)
 */
const generateStandardReport = async (submission, student = {}, assessment = {}) => {
  const doc = new PDFDocument({ margin: 48, size: "A4" });
  const stream = new PassThrough();
  doc.pipe(stream);

  // Header (logo + title with proper spacing)
  addHeader(doc, "Standard Assessment Report", "#004D4D");

  // Student & Assessment Info section - FIXED LAYOUT
  const infoSectionTop = doc.y;
  
  // Different widths for different content types
  const studentNameCardWidth = 150;  // For student name
  const assessmentCardWidth = 220;   // Wider for assessment names
  const dateCardWidth = 100;         // Smaller for date
  
  const cardHeight = 40;
  const cardGap = 10;
  
  // First row of info cards
  const studentName = student?.name || "—";
  const assessmentName = assessment?.assessmentName || assessment?.assessmentTitle || "—";
  const dateStr = formatDate(submission?.submittedAt || submission?.createdAt);
  
  let currentX = doc.page.margins.left;
  let currentY = infoSectionTop;
  
  // Draw STUDENT NAME card
  currentY = drawInfoCard(doc, currentX, currentY, studentNameCardWidth, cardHeight, "Student Name", studentName);
  currentX += studentNameCardWidth + cardGap;
  
  // Draw ASSESSMENT card (wider for long names)
  currentY = infoSectionTop; // Reset Y for second card
  currentY = drawInfoCard(doc, currentX, currentY, assessmentCardWidth, cardHeight, "Assessment", assessmentName);
  currentX += assessmentCardWidth + cardGap;
  
  // Draw DATE card (smaller)
  currentY = infoSectionTop; // Reset Y for third card
  currentY = drawInfoCard(doc, currentX, currentY, dateCardWidth, cardHeight, "Date", dateStr);
  
  // Move cursor to below the info cards
  doc.y = infoSectionTop + cardHeight + 15;

  // Score summary section
  const score = submission?.score ?? 0;
  const totalMarks = submission?.totalMarks ?? 0;
  const percentage = typeof submission?.percentage === "number" 
    ? submission.percentage.toFixed(1) 
    : (totalMarks > 0 ? ((score / totalMarks) * 100).toFixed(1) : "0.0");

  const scoreCardWidth = 180;
  const scoreCardHeight = 100;
  const scoreCardX = (doc.page.width - scoreCardWidth) / 2; // Center the score card

  drawScoreCard(doc, scoreCardX, doc.y, scoreCardWidth, scoreCardHeight, score, totalMarks, percentage, "#004D4D");
  
  // Move cursor below the score card
  doc.y += scoreCardHeight + 15;

  // Detailed responses table
  const responses = Array.isArray(submission?.responses) ? submission.responses : [];

  if (responses.length > 0) {
    doc.font("Helvetica-Bold").fontSize(14).fillColor("#004D4D").text("Detailed Responses", { underline: true });

    const startX = doc.page.margins.left;
    const contentWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;

    // Columns: Question | Your Answer | Correct Answer | Points Earned
    const colWidths = [
      Math.floor(contentWidth * 0.50), // Question
      Math.floor(contentWidth * 0.16), // Your Answer
      Math.floor(contentWidth * 0.16), // Correct Answer
      Math.floor(contentWidth * 0.18), // Points Earned
    ];

    const headers = ["Question", "Your Answer", "Correct Answer", "Points Earned"];

    const rows = responses.map((r) => [
      (r.questionText || "").replace(/\s+/g, " ").trim().slice(0, 120) + 
        ((r.questionText && r.questionText.length > 120) ? "..." : ""), // Truncate long questions
      (r.studentAnswer === null || r.studentAnswer === undefined) ? "—" : String(r.studentAnswer),
      (r.correctAnswer === null || r.correctAnswer === undefined) ? "—" : String(r.correctAnswer),
      r.isCorrect ? (r.marks ?? 1) : 0
    ]);

    const finalY = drawTable(doc, doc.y, startX, colWidths, headers, rows);
    doc.y = finalY + 10;
  }

  addFooter(doc);

  doc.end();
  return await streamToBuffer(stream);
};

/**
 * SAT Assessment Report
 */
const generateSatReport = async (submission, student = {}, assessment = {}) => {
  const doc = new PDFDocument({ margin: 48, size: "A4" });
  const stream = new PassThrough();
  doc.pipe(stream);

  addHeader(doc, "SAT Score Report", "#00205B");

  // Student info section with cards - FIXED LAYOUT
  const infoSectionTop = doc.y;
  
  // Different widths for different content types
  const studentNameCardWidth = 150;  // For student name
  const emailCardWidth = 200;        // Wider for email
  const testDateCardWidth = 120;     // Smaller for date
  
  const cardHeight = 40;
  const cardGap = 10;
  
  const studentName = student?.name || "—";
  const studentEmail = student?.email || "—";
  const dateStr = formatDate(submission?.submittedAt || submission?.createdAt);
  
  let currentX = doc.page.margins.left;
  let currentY = infoSectionTop;
  
  // Draw STUDENT NAME card
  currentY = drawInfoCard(doc, currentX, currentY, studentNameCardWidth, cardHeight, "Student Name", studentName, "#00205B");
  currentX += studentNameCardWidth + cardGap;
  
  // Draw EMAIL card
  currentY = infoSectionTop; // Reset Y for second card
  currentY = drawInfoCard(doc, currentX, currentY, emailCardWidth, cardHeight, "Email", studentEmail, "#00205B");
  currentX += emailCardWidth + cardGap;
  
  // Draw TEST DATE card (smaller)
  currentY = infoSectionTop; // Reset Y for third card
  currentY = drawInfoCard(doc, currentX, currentY, testDateCardWidth, cardHeight, "Test Date", dateStr, "#00205B");
  
  // Move cursor to below the info cards
  doc.y = infoSectionTop + cardHeight + 20;

  // Section Scores
  const rwScore = Math.round(((submission?.percentage ?? 0) / 100) * 600 + 200);
  const mathScore = Math.round(((submission?.percentage ?? 0) / 100) * 600 + 200);
  const totalScaled = Math.round((rwScore + mathScore) / 2) * 2;

  // Draw two score cards side by side
  const contentWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
  const scoreCardWidth = (contentWidth - 20) / 2;
  const scoreCardHeight = 100;
  const leftX = doc.page.margins.left;
  const topY = doc.y;

  // RW score card
  const rwPercentage = ((rwScore - 200) / 600 * 100).toFixed(1);
  drawScoreCard(doc, leftX, topY, scoreCardWidth, scoreCardHeight, rwScore, 800, rwPercentage, "#00205B");

  // Math score card
  const mathPercentage = ((mathScore - 200) / 600 * 100).toFixed(1);
  drawScoreCard(doc, leftX + scoreCardWidth + 20, topY, scoreCardWidth, scoreCardHeight, mathScore, 800, mathPercentage, "#00205B");

  doc.y = topY + scoreCardHeight + 20;

  // Total Score card
  const totalPercentage = ((totalScaled - 400) / 1200 * 100).toFixed(1);
  const totalCardWidth = 200;
  const totalCardX = (doc.page.width - totalCardWidth) / 2;
  
  drawScoreCard(doc, totalCardX, doc.y, totalCardWidth, scoreCardHeight, totalScaled, 1600, totalPercentage, "#00205B");
  
  doc.y += scoreCardHeight + 15;

  // Percentile statement
  const percentile = (submission?.percentage ?? 0) >= 80 ? 90 : (submission?.percentage ?? 0) >= 50 ? 70 : 40;
  doc.font("Helvetica").fontSize(12).fillColor("black")
     .text(`Your score is higher than approximately ${percentile}% of students nationally.`, { align: "center" });

  addFooter(doc);

  doc.end();
  return await streamToBuffer(stream);
};

/**
 * Main function: decides template based on type
 */
const generateScoreReportPDF = async (submission, student, assessment, type = "standard") => {
  if (type === "sat") {
    return await generateSatReport(submission, student, assessment);
  }
  return await generateStandardReport(submission, student, assessment);
};

module.exports = { generateScoreReportPDF };